Software Engineering Principles : guides the development of software system to ensure quality, maintainability, efficiency of code, reusability etc..

 1. Separation of Concern : Divide the program into distinct sections, thereby enhancing the modularity
 2. Abstraction (what rather than how)
 3. Anticipation of Change : 
        - Generality (de-coupled codes)
        - Incremental Development
        - Consistency of Look and feel
 4. DRY : Do Not Repeat Yourselves
 5. KISS : Keep it Simple ! Stupid
 6. YAGNI : You Aren't Gonna Need It (avoid features and functions that are not required)
 7. SOLID : Are design Principles

   S - Single Responsibility Principle (SRP) - A class, structure in the code should have always one job to do
   O - Open Close Principle (OCP) - a S/W component is open for extensions and closed for modifications
   L - Liskov's Substitution Principle (LSP) - is an extension of OCP, where derived types should not change the behaviour of the base type (Usage of Interfaces)
   I - Interface Segregation Principle (ISP) - In order not to force the Implementing class to implement all methods, of the interface, create multiple thin interfaces with minimal methods
   D - Dependency Inversion principle (DIP) - States that high level modules/classes (consumer/client) should not depend on low level modules/classes (implementing classes). Both should depend on Abstraction (abstract class/interface - Layered architecture)

DIP as a design principle suggests solution to the dependency problem, but does not specify any technique for the same

IoC : Inversion of Control  - is the actual mechanism to implement DIP

DI - Dependency Injection - is a design pattern that can inject the concrete implementations of the low level module components into high level modules

Ioc is a principle and DI is the implementation.

DI can be used as below :
  1. Constructor Injection : Instance of the dependency type can be passed as an argument to the constructor of the dependent type
  2. Method Injection : Instance of the dependency type can be passed as an argument to the method of a dependent type
  3. Property Injection : Instance of the dependency type can be passed as an argument to the specific property of the dependent type

Based on the SOLID principles, we have software design patterns
-------------------------------------------------------------------
Benefits of Design Pattern Usage either in small or large enterprise applications

Code Quality - clean, maintainable, reusable code
Scalability - capable of handling future demands
Flexibility - enables easier modifications(extensions) and enhancements to the code
Separation of Concerns - improves modularity and reduces tight coupling
Code Consistency - can lead to more consistent and readable code



1. Creational Pattern: 

   - 1. Factory Pattern : Suggests to have a factory where types of objects required by the user are created and initialized
     
       1.1  Factory Method Pattern : Provides an abstraction for creating objects in a super class, but allows the subclasses to decide the type of objects and create them. 

   - Abstract Factory Pattern : As per GOF, this pattern provides a way to encapsulate a group of factories with a common theme without specifying their concrete classes
          Car and the Bike Details

  Abstract Products : interfaces for creating abstract products ( ICar and IBike)
  Concrete Products : classes that implement the abstract product (RegularBike, RegularCar, SportsBike, SportsCar)
  Abstract Factory : interface that creates abstract products (IvehicleFactory)
  Concrete Factory : classes that implement the abstract factory interface (RegularVehicleFactory, SportsVehicleFactory)
  Client : uses abstract factory and abstract product to create a family of similar themed products

Hands On : Design a C# application that makes use of the Abstract Factory Pattern in a Furniture Shop

Modern Furniture's  (Chair and Sofa)
Vintage Furniture's (Chair and Sofa)

 IChair {
      void SitOn(); }

 ISofa {
       void LayOn(); }

 IFurnitureFactory { 
          Ichair CreateChair()
          ISofa CreateSofa()
}

ModernFurnitureFactory { }
VintageFurnitureFactory{}

   - SingleTon Pattern


2. Structural pattern :


3. Behavioural Pattern :



     
